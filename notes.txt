insert(collection, attrs) // add or replace by id, returns added record

updateById(collection, id, attrs) // merges and returns the record
updateWhere(collection, query, attrs) // merges and returns updated collection

replaceById(collection, id, attrs) //  replace by id, returns record

removeById(collection, id)  // deleted and returns deleted record
removeWhere(collection, query) // returns removed records in collecton

          object              | collection

add       insert              | insertAll
update    updateById          | updateAll
replace   replaceById         | replaceAll
delete    removeById          | removeAll

insert(collection || object, attrs || collection)
  collection in store, collection to add
    - concat

  collection in store, object to add
    - push

  object in store, object to add
    - replace (assignment)

  throw: object in store, collection to add


update(collection || object, id, attrs = null, {replace: true})
  throw: attrs are a collection

  collection in store, object to update
    - find index by id
    - splice + merge object attrs

  collection in store, object to update, replace: true
    - find index by id
    - splice + new attrs

  collection in store, null
    - find index by id
    - splice + no attrs

  object in store, object to update
    - merge object attrs

  object in store, object to update, replace: true
    - replace (assignment)

  object in store, null
    - null (assignment)


updateAll(storeCollection, collectionToUpdate, {replace: true || remove: true})
  throw: path is not a collection
  throw: identifier not found in collectionToUpdate

  update
    - each record in collectionToUpdate
      update(storeCollection, record.identifier, record)

  replace
    - each record in collectionToUpdate
      update(storeCollection, record.identifier, {replace: true})

  remove
    - each record in collectionToUpdate
      update(storeCollection, record.identifier, {remove: true})






Chores

1. Propogate promise errors! (re-raise in catch()? )

DONE! 2. Make axiosAdapter and plain-js-store-adapter Singletons?
  - set runtime config (root, model, identifier) via API methods:
    - `ajaxAdapter.setConfig({root: 'foo', model: 'bar'})`
    - access config inside adapters from `this.identifier` or `this.root`

3. Move storeAdapter and ajaxAdapter code and tests into separate files

Tests

1. Finish integration tests for: create, update, delete

2. Tests for public store adapter methods

3. Store: check models get instantiated on create and inserted into the store

4. Test dynamic segments in parse-url

5. Write big integration test script to make sure no bugs with Singleton state

Features

1. Merge find/findAll clientQuery into http params hash
  - should be done in configuration.js

DONE! 2. Expose raw store `cache` from store adapter

DONE! 3. Expose raw ajax lib (`http`) from axios adapter
  - make sure you can set global config: headers, etc.

4. Set global and per resource TTL (unix timestamp) cache busting


-----------------------------
v2.0

- Integrate normalzr or handle normalizing data automatically?

-------------------------------------------

// REST API
//
// store.findAll('todos', attrs, prams);  // GET /todos?attrs     READ #index
// store.find('todos', {id: 1}, params);  // GET /todos/1?params  READ #show
//
// store.create('todos', null, attrs);    // POST /todos          CREATE #create
// store.update('todos', {id: 1}, attrs); // PUT /todos/1         UPDATE #update
//
// store.delete('todos', 1)               // DELETE /todos/1      DELETE #destroy
//
// CONFIG
//
// controller.addModules({
//   store: REST({}, {
//     todos: {url: 'http://localhost:4000/todos', root: false, identifier: 'uid'}, // identifier: default to id
//     // user:        {url: 'api/v1/users', root: 'practice_users'},
//     comments:    {url: 'todos/:todo_id/comments/'},
//     // currentUser: {url: `${host}/api/v1/me.json`, root: false},
//     // tasks: {url: 'patients/:patient_guid/tasks, root: false, identifier: 'uid'},
//   }),
//
//  USAGE
//
// ({input, state, services}) => {
// services.store.find(
//     'todos',
//     {id: input.id},
//     { user_id: state.get('user_id'),
//       params: {user_id: state.get('currentUserId')},
//       headers: {token: state.get('authToken')}
//     })
//     .then({data: [] || {})
//      .catch()
// },
//

// describe('', () => {
//   expect().to.be.ok
// });

Store stuff:

{todos: null}
{todos: []}
{todos: [{}]}
{todos: [{id: 1, foo: 'foo'}]}

responses:
null,
[],
[{}]
[{id: 1, foo: 'foo'}]


{todo: null}
{todo: {}}
{todo: {id: 1, foo: 'foo'}}

responses:
null,
{},
{id: 1, 'foo'},
''
